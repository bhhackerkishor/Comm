<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple WebRTC Matchmaker</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background-color: #f4f4f9; }
        #status-area { margin-bottom: 20px; padding: 10px; border-radius: 5px; background-color: #e3f2fd; color: #1565c0; font-weight: bold; }
        .controls, .video-container { margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #fff; }
        button { padding: 10px 15px; margin-right: 10px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; }
        button:hover:not(:disabled) { background-color: #45a049; }
        video { width: 45%; height: auto; border: 1px solid #333; margin: 5px; background-color: black; border-radius: 5px; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <h1>ü§ù Random Video Chat</h1>

    <div id="status-area">Status: Not Connected</div>

    <div id="register-section">
        <input type="text" id="username-input" placeholder="Enter your name" value="User_A">
        <button onclick="registerUser()">Register</button>
    </div>

    <div class="controls hidden" id="call-controls">
        <button onclick="findPartner()" id="find-btn">Find Partner</button>
        <button onclick="endCall()" id="end-btn" disabled>End Call</button>
    </div>

    <div class="video-container hidden" id="video-area">
        <h3>Current Partner: <span id="partner-name">...</span></h3>
        <video id="local-video" autoplay muted></video>
        <video id="remote-video" autoplay></video>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // --- Configuration ---
        // **IMPORTANT:** Must match your Node.js server port!
        const SERVER_URL = "https://server-09p9.onrender.com";
        
        // Public STUN server to help peers find each other (essential for WebRTC)
        const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }]; 

        // --- Global State ---
        let socket;
        let peerConnection;
        let localStream;
        let isInitiator = false; // True if this client initiates the WebRTC offer

        // --- DOM Elements ---
        const statusArea = document.getElementById('status-area');
        const registerSection = document.getElementById('register-section');
        const callControls = document.getElementById('call-controls');
        const videoArea = document.getElementById('video-area');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const partnerNameEl = document.getElementById('partner-name');
        const findButton = document.getElementById('find-btn');
        const endButton = document.getElementById('end-btn');

        // --- Utility & UI Functions ---
        function updateStatus(message) {
            statusArea.innerHTML = `Status: **${message}**`;
        }

        function showCallUI(partnerName) {
            registerSection.classList.add('hidden');
            callControls.classList.remove('hidden');
            videoArea.classList.remove('hidden');
            findButton.disabled = true;
            endButton.disabled = false;
            partnerNameEl.textContent = partnerName;
            updateStatus("In call with " + partnerName);
        }

        function resetUI(message = "Registered and Ready") {
            registerSection.classList.remove('hidden');
            callControls.classList.remove('hidden');
            videoArea.classList.add('hidden');
            findButton.disabled = false;
            endButton.disabled = true;
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            partnerNameEl.textContent = "...";
            updateStatus(message);
        }

        // --- Socket.IO Handlers ---
        function initSocket() {
            socket = io(SERVER_URL);

            socket.on("connect", () => {
                updateStatus("Connected to server. Please register your name.");
            });

            socket.on("status", (msg) => {
                updateStatus(msg);
                if (msg.startsWith("Registered")) {
                    resetUI(msg);
                    console.log("working");
                }
            });

            socket.on("waiting", (msg) => {
                updateStatus(msg);
                findButton.disabled = true;
            });

            socket.on("partner-found", async ({ partnerId, partnerName }) => {
                
                
                // If we initiated the search (isInitiator is true), we make the Offer
                await setupPeerConnection();
                if (isInitiator) {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    socket.emit("signal", { sdp: peerConnection.localDescription });
                    console.log("WebRTC Offer sent.");
                }
            });

            // Handles the WebRTC signaling data from the partner via the server
            socket.on("signal", async (data) => {
                if (!peerConnection) {
                    // Must not have been the initiator, so set up the connection now
                    await setupPeerConnection();
                }

                if (data.sdp) {
                    const sdp = new RTCSessionDescription(data.sdp);
                    await peerConnection.setRemoteDescription(sdp);

                    if (sdp.type === 'offer') {
                        // Received an Offer, now create and send the Answer
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        socket.emit("signal", { sdp: peerConnection.localDescription });
                        console.log("WebRTC Answer sent.");
                    }
                } else if (data.ice) {
                    try {
                        // Add received network configuration data
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.ice));
                    } catch (e) {
                        console.error("Error adding received ICE candidate:", e);
                    }
                }
            });

            socket.on("call-ended", () => {
                cleanupCall("Partner ended the call.");
            });

            socket.on("partner-left", () => {
                cleanupCall("Partner disconnected from the server.");
            });

            socket.on("disconnect", () => {
                cleanupCall("Lost connection to the signaling server.");
            });
        }

        // --- WebRTC Core Functions ---

        async function getMedia() {
            try {
                // Request camera and microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                return localStream;
            } catch (err) {
                console.error("Error getting media stream (camera/mic):", err);
                updateStatus(`ERROR: Cannot access camera/mic. Details: ${err.message}`);
                throw err;
            }
        }

        async function setupPeerConnection() {
            if (peerConnection) peerConnection.close();
            
            await getMedia(); // Ensure we have the stream first

            peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            
            // Add local tracks to the peer connection
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // Handler for receiving remote tracks (partner's video/audio)
            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    console.log('Received remote stream');
                }
            };

            // Handler for gathering and sending ICE candidates (network info)
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit("signal", { ice: event.candidate });
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                 console.log('ICE connection state:', peerConnection.iceConnectionState);
                 updateStatus(`ICE Status: ${peerConnection.iceConnectionState}`);
            };
        }

        function cleanupCall(message) {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop()); // Stop camera/mic
            }
            if (peerConnection) {
                peerConnection.close();
            }
            localStream = null;
            peerConnection = null;
            isInitiator = false;
            resetUI(message);
        }

        // --- User Actions ---
        function registerUser() {
            const name = document.getElementById('username-input').value.trim();
            if (!name) return alert("Please enter a name.");
            
            if (!socket) initSocket(); // First time connecting
            
            if (socket && socket.connected) {
                socket.emit("register", name);
            } else {
                updateStatus("Connecting to server... Please wait a moment.");
            }
        }

        function findPartner() {
            if (!socket || !socket.connected) {
                return updateStatus("Not connected to server!");
            }
            
            // This flag marks this client as the one who will create the WebRTC Offer
            isInitiator = true; 
            updateStatus("Searching for a partner...");
            findButton.disabled = true;
            socket.emit("find-partner");
        }

        function endCall() {
            if (socket && socket.connected) {
                socket.emit("end-call");
            }
            cleanupCall("Call manually ended.");
        }

        // Initialize socket on page load
        document.addEventListener('DOMContentLoaded', initSocket);

    </script>
</body>
</html>
