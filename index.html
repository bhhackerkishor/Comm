<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <title>TalkPair</title>
Â  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
Â  <style>
Â  Â  * { box-sizing: border-box; }
Â  Â  body {
Â  Â  Â  background: linear-gradient(145deg, #1a1c1f, #0c0d0f);
Â  Â  Â  color: #fff;
Â  Â  Â  font-family: 'Poppins', sans-serif;
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: center;
Â  Â  Â  height: 100vh;
Â  Â  Â  margin: 0;
Â  Â  }

Â  Â  .card {
Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  border: 1px solid rgba(255, 255, 255, 0.1);
Â  Â  Â  backdrop-filter: blur(10px);
Â  Â  Â  border-radius: 20px;
Â  Â  Â  padding: 30px 40px;
Â  Â  Â  text-align: center;
Â  Â  Â  width: 360px;
Â  Â  Â  box-shadow: 0 4px 30px rgba(0,0,0,0.3);
Â  Â  }

Â  Â  h1 {
Â  Â  Â  margin-bottom: 15px;
Â  Â  Â  font-weight: 600;
Â  Â  }

Â  Â  input {
Â  Â  Â  width: 100%;
Â  Â  Â  padding: 10px 14px;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  border: none;
Â  Â  Â  outline: none;
Â  Â  Â  font-size: 15px;
Â  Â  Â  margin-bottom: 15px;
Â  Â  Â  background: rgba(255,255,255,0.1);
Â  Â  Â  color: white;
Â  Â  }

Â  Â  .controls {
Â  Â  Â  display: flex;
Â  Â  Â  flex-wrap: wrap;
Â  Â  Â  justify-content: center;
Â  Â  Â  gap: 10px;
Â  Â  Â  margin-top: 10px;
Â  Â  }

Â  Â  button {
Â  Â  Â  background: rgba(255,255,255,0.1);
Â  Â  Â  color: white;
Â  Â  Â  border: 1px solid rgba(255,255,255,0.2);
Â  Â  Â  border-radius: 12px;
Â  Â  Â  padding: 10px 16px;
Â  Â  Â  cursor: pointer;
Â  Â  Â  font-size: 14px;
Â  Â  Â  transition: all 0.25s ease;
Â  Â  Â  min-width: 90px;
Â  Â  }

Â  Â  button:hover { background: rgba(255,255,255,0.2); }
Â  Â  button:disabled { opacity: 0.4; cursor: not-allowed; }

Â  Â  button.active { background: #0f9d58; }
Â  Â  button.danger { background: #d93025; }

Â  Â  #status {
Â  Â  Â  margin-top: 15px;
Â  Â  Â  font-size: 14px;
Â  Â  Â  color: #aaa;
Â  Â  Â  min-height: 20px;
Â  Â  }

Â  Â  #partner {
Â  Â  Â  font-weight: 600;
Â  Â  Â  color: #00c3ff;
Â  Â  Â  margin-top: 8px;
Â  Â  }

Â  Â  .ringing { animation: blink 1s infinite; color: #ffb300; }
Â  Â  @keyframes blink { 50% { opacity: 0.3; } }

Â  Â  #timer { margin-top: 10px; font-size: 13px; color: #ccc; }
Â  </style>
</head>
<body>
Â  <div class="card">
Â  Â  <h1>ğŸ™ï¸ TalkPair</h1>
Â  Â  <input id="name" placeholder="Enter your name" />
Â  Â  <div class="controls">
Â  Â  Â  <button id="register">Register</button>
Â  Â  Â  <button id="find" disabled>Find</button>
Â  Â  Â  <button id="end" class="danger" disabled>End</button>
Â  Â  Â  <button id="mute" disabled>ğŸ¤ Mic On</button>
Â  Â  Â  <button id="speaker" disabled>ğŸ”Š Speaker On</button>
Â  Â  </div>
Â  Â  <p id="partner"></p>
Â  Â  <p id="status">Not connected</p>
Â  Â  <p id="timer"></p>
Â  </div>

Â  <audio id="localAudio" autoplay muted></audio>
Â  <audio id="remoteAudio" autoplay></audio>

Â  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
Â  <script>
Â  Â  const socket = io("https://server-09p9.onrender.com");
Â  Â  const nameInput = document.getElementById("name");
Â  Â  const btnRegister = document.getElementById("register");
Â  Â  const btnFind = document.getElementById("find");
Â  Â  const btnEnd = document.getElementById("end");
Â  Â  const btnMute = document.getElementById("mute");
Â  Â  const btnSpeaker = document.getElementById("speaker");
Â  Â  const statusEl = document.getElementById("status");
Â  Â  const partnerEl = document.getElementById("partner");
Â  Â  const timerEl = document.getElementById("timer");
Â  Â  const localAudio = document.getElementById("localAudio");
Â  Â  const remoteAudio = document.getElementById("remoteAudio");

Â  Â  let pc, localStream, partnerId, isMuted = false, speakerOn = true, timer, callStart;
Â  Â  let isRegistered = false; // New state variable

Â  Â  // Helper function to update button states based on application status
Â  Â  function updateUI(isConnecting = false, isConnected = false) {
Â  Â  Â  btnRegister.disabled = isRegistered;
Â  Â  Â  nameInput.disabled = isRegistered;
Â  Â  Â  btnFind.disabled = !isRegistered || isConnecting || isConnected;
Â  Â  Â  btnEnd.disabled = !isConnected;
Â  Â  Â  btnMute.disabled = !isConnected;
Â  Â  Â  btnSpeaker.disabled = !isConnected;
Â  Â  Â  
Â  Â  Â  btnMute.textContent = isMuted ? "ğŸ”‡ Mic Off" : "ğŸ¤ Mic On";
Â  Â  Â  btnMute.classList.toggle("active", isMuted);
Â  Â  Â  
Â  Â  Â  btnSpeaker.textContent = speakerOn ? "ğŸ”Š Speaker On" : "ğŸ”ˆ Speaker Off";
Â  Â  Â  btnSpeaker.classList.toggle("active", !speakerOn); // Active when speaker is OFF (muted)
Â  Â  }

Â  Â  async function resetConnection() {
Â  Â  Â  if (pc) { 
Â  Â  Â  Â  // Explicitly check if the PC state is not closed before calling close
Â  Â  Â  Â  if (pc.connectionState !== 'closed') {
Â  Â  Â  Â  Â  pc.close(); 
Â  Â  Â  Â  }
Â  Â  Â  Â  pc = null;
Â  Â  Â  }
Â  Â  Â  if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
Â  Â  Â  partnerId = null;
Â  Â  Â  remoteAudio.srcObject = null;
Â  Â  Â  partnerEl.textContent = "";
Â  Â  Â  statusEl.classList.remove("ringing");
Â  Â  Â  clearInterval(timer);
Â  Â  Â  timerEl.textContent = "";
Â  Â  Â  // Reset controls to initial state after registration
Â  Â  Â  statusEl.textContent = isRegistered ? "Ready to find partner" : "Not connected";
Â  Â  Â  updateUI();
Â  Â  }

Â  Â  async function initPeer() {
Â  Â  Â  // Ensure a clean slate before starting a new connection
Â  Â  Â  await resetConnection(); 
Â  Â  Â  
Â  Â  Â  pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });

Â  Â  Â  // Get media stream and add tracks
Â  Â  Â  try {
Â  Â  Â  Â  localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
Â  Â  Â  Â  localAudio.srcObject = localStream;
Â  Â  Â  Â  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Could not get media stream:", err);
Â  Â  Â  Â  statusEl.textContent = "ğŸš« Error: Please grant mic access.";
Â  Â  Â  Â  updateUI();
Â  Â  Â  Â  return false; // Indicate failure
Â  Â  Â  }

Â  Â  Â  pc.ontrack = e => { 
Â  Â  Â  Â  // Set up remote audio when track is received
Â  Â  Â  Â  if (remoteAudio.srcObject !== e.streams[0]) {
Â  Â  Â  Â  Â  remoteAudio.srcObject = e.streams[0]; 
Â  Â  Â  Â  }
Â  Â  Â  };
Â  Â  Â  
Â  Â  Â  // ICE candidate handling
Â  Â  Â  pc.onicecandidate = e => { if (e.candidate && partnerId) socket.emit("signal", e.candidate); };

Â  Â  Â  // Log connection state changes for debugging
Â  Â  Â  pc.onconnectionstatechange = () => {
Â  Â  Â  Â  console.log("Peer connection state:", pc.connectionState);
Â  Â  Â  Â  if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
Â  Â  Â  Â  Â  // Handle unexpected disconnects
Â  Â  Â  Â  Â  if (partnerId) { // Only show partner-left message if we had a partner
Â  Â  Â  Â  Â  Â  resetConnection();
Â  Â  Â  Â  Â  Â  statusEl.textContent = "âš ï¸ Partner disconnected unexpectedly.";
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  };
Â  Â  Â  return true; // Indicate success
Â  Â  }

Â  Â  function startTimer() {
Â  Â  Â  callStart = Date.now();
Â  Â  Â  clearInterval(timer); // Clear any existing timer just in case
Â  Â  Â  timer = setInterval(() => {
Â  Â  Â  Â  const diff = Math.floor((Date.now() - callStart) / 1000);
Â  Â  Â  Â  const m = String(Math.floor(diff / 60)).padStart(2, "0");
Â  Â  Â  Â  const s = String(diff % 60).padStart(2, "0");
Â  Â  Â  Â  timerEl.textContent = `â±ï¸ ${m}:${s}`;
Â  Â  Â  }, 1000);
Â  Â  }

Â  Â  // --- Event Listeners ---

Â  Â  btnRegister.onclick = () => {
Â  Â  Â  const name = nameInput.value.trim();
Â  Â  Â  if (!name) return alert("Enter name first, you sly dog.");
Â  Â  Â  socket.emit("register", name);
Â  Â  Â  isRegistered = true; // Mark as registered immediately
Â  Â  Â  statusEl.textContent = "âœ… Registered as " + name;
Â  Â  Â  updateUI();
Â  Â  };

Â  Â  btnFind.onclick = async () => {
Â  Â  Â  if (!isRegistered) return alert("You must register first!");
Â  Â  Â  
Â  Â  Â  await resetConnection(); // Start fresh before finding
Â  Â  Â  
Â  Â  Â  socket.emit("find-partner");
Â  Â  Â  statusEl.textContent = "ğŸ” Finding partner...";
Â  Â  Â  updateUI(true, false); // Update UI to connecting state
Â  Â  };

Â  Â  btnEnd.onclick = async () => {
Â  Â  Â  if (partnerId) {
Â  Â  Â  Â  socket.emit("end-call");
Â  Â  Â  }
Â  Â  Â  await resetConnection();
Â  Â  Â  statusEl.textContent = "âŒ Call ended. Click Find to reconnect.";
Â  Â  };

Â  Â  btnMute.onclick = () => {
Â  Â  Â  if (!localStream) return;
Â  Â  Â  isMuted = !isMuted;
Â  Â  Â  // Mute/Unmute local audio track
Â  Â  Â  localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
Â  Â  Â  updateUI(false, true); // Update button text/class
Â  Â  };

Â  Â  btnSpeaker.onclick = () => {
Â  Â  Â  speakerOn = !speakerOn;
Â  Â  Â  // Mute/Unmute remote audio element
Â  Â  Â  remoteAudio.muted = !speakerOn; 
Â  Â  Â  updateUI(false, true); // Update button text/class
Â  Â  };

Â  Â  // --- Socket.io Handlers ---
Â  Â  
Â  Â  socket.on("waiting", msg => statusEl.textContent = msg);

Â  Â  socket.on("partner-found", async ({ partnerId: id, partnerName }) => {
Â  Â  Â  // Make sure we aren't already connected to someone else (logic guard)
Â  Â  Â  if (partnerId) return; 
Â  Â  Â  
Â  Â  Â  partnerId = id;
Â  Â  Â  partnerEl.textContent = "Partner: " + partnerName;
Â  Â  Â  statusEl.textContent = "ğŸ“ Ringing...";
Â  Â  Â  statusEl.classList.add("ringing");
Â  Â  Â  
Â  Â  Â  if (!(await initPeer())) return; // Initialize peer connection. Stop if it fails (e.g., no mic access)
Â  Â  Â  
Â  Â  Â  // Caller: create and send offer
Â  Â  Â  const offer = await pc.createOffer();
Â  Â  Â  await pc.setLocalDescription(offer);
Â  Â  Â  socket.emit("signal", offer);
Â  Â  Â  
Â  Â  Â  updateUI(true, false);
Â  Â  });

Â  Â  socket.on("signal", async data => {
Â  Â  Â  if (!pc) {
Â  Â  Â  Â  // This client is the callee
Â  Â  Â  Â  if (data.type === "offer") {
Â  Â  Â  Â  Â  // We only initPeer if we receive an offer and don't have a PC yet
Â  Â  Â  Â  Â  if (!(await initPeer())) return;
Â  Â  Â  Â  } else if (!data.type) {
Â  Â  Â  Â  Â  // Ignore late signals (like ICE candidates) if no call is active
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (data.type === "offer") {
Â  Â  Â  Â  // Callee: set remote offer, create, and send answer
Â  Â  Â  Â  await pc.setRemoteDescription(new RTCSessionDescription(data));
Â  Â  Â  Â  const answer = await pc.createAnswer();
Â  Â  Â  Â  await pc.setLocalDescription(answer);
Â  Â  Â  Â  socket.emit("signal", answer);
Â  Â  Â  Â  
Â  Â  Â  Â  // Note: Partner ID will be set by a separate "partner-found" event on the callee side
Â  Â  Â  Â  // We assume the server sends "partner-found" to both parties before the signalling begins
Â  Â  Â  Â  
Â  Â  Â  } else if (data.type === "answer") {
Â  Â  Â  Â  // Caller: set remote answer
Â  Â  Â  Â  await pc.setRemoteDescription(new RTCSessionDescription(data));
Â  Â  Â  Â  statusEl.textContent = "ğŸŸ¢ Connected";
Â  Â  Â  Â  statusEl.classList.remove("ringing");
Â  Â  Â  Â  updateUI(false, true); // Update UI to connected state
Â  Â  Â  Â  startTimer();
Â  Â  Â  } else if (data.candidate && pc.remoteDescription) {
Â  Â  Â  Â  // ICE candidate
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  await pc.addIceCandidate(new RTCIceCandidate(data));
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  console.error("Error adding ICE candidate:", e);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  });
Â  Â  
Â  Â  // The callee is connected once both sides have set up their descriptions. 
Â  Â  // This event ensures both sides know they are fully connected and enables controls.
Â  Â  socket.on("call-connected", () => {
Â  Â  Â  // This ensures the Callee also updates their UI and starts the timer
Â  Â  Â  if (partnerId && pc) { 
Â  Â  Â  Â  statusEl.textContent = "ğŸŸ¢ Connected";
Â  Â  Â  Â  statusEl.classList.remove("ringing");
Â  Â  Â  Â  updateUI(false, true);
Â  Â  Â  Â  startTimer();
Â  Â  Â  }
Â  Â  });

Â  Â  socket.on("call-ended", async () => {
Â  Â  Â  if (partnerId) { // Only run if we actually had a partner
Â  Â  Â  Â  await resetConnection();
Â  Â  Â  Â  statusEl.textContent = "ğŸ“´ Partner ended the call. Click Find to reconnect.";
Â  Â  Â  }
Â  Â  });

Â  Â  socket.on("partner-left", async () => {
Â  Â  Â  if (partnerId) { // Only run if we actually had a partner
Â  Â  Â  Â  await resetConnection();
Â  Â  Â  Â  statusEl.textContent = "ğŸ”´ Partner disconnected from server.";
Â  Â  Â  }
Â  Â  });
Â  Â  
Â  Â  // Initialize UI state on load
Â  Â  updateUI(); 
Â  </script>
</body>
</html>
