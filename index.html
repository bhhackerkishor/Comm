<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkPair â€” Fullscreen Remote</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg1: #0f1113;
      --card: #131518;
      --accent: #0078ff;
      --muted: #2b2f36;
      --glass: rgba(255,255,255,0.03);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body { height: 100%; }
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(145deg, #0b0c0e, #101215);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    /* Wrapper that will host the "call screen" */
    .call-wrap {
      width: 100%;
      max-width: 1200px;
      height: 80vh;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
    }

    /* Controls & top area for pre-call UI */
    .topbar {
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      background: linear-gradient(180deg, rgba(0,0,0,0.25), transparent);
      z-index: 30;
    }
    .topbar input {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      outline: none;
      background: var(--glass);
      color: #fff;
      width: 220px;
    }
    .topbar button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
    }
    .topbar button:disabled { opacity: 0.45; cursor: not-allowed; }

    /* Video stage */
    .stage {
      position: relative;
      flex: 1;
      background: black;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Remote video - fills available area */
    #remoteVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: black;
    }

    /* Local preview - small top-left */
    #localContainer {
      position: absolute;
      top: 16px;
      left: 16px;
      width: 180px;
      height: 120px;
      border-radius: 10px;
      overflow: hidden;
      z-index: 40;
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
      background: rgba(0,0,0,0.35);
      display: none; /* hidden until stream exists */
    }
    #localVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* mirror local */
    }
    /* small label under local preview */
    .local-label {
      position: absolute;
      bottom: 6px;
      left: 6px;
      font-size: 12px;
      padding: 2px 6px;
      background: rgba(0,0,0,0.35);
      border-radius: 6px;
    }

    /* Sticky control bar at bottom overlay */
    .controls-bottom {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      z-index: 50;
      background: rgba(18,20,23,0.55);
      backdrop-filter: blur(6px);
      border-radius: 999px;
      padding: 8px;
      display: flex;
      gap: 10px;
      align-items: center;
      box-shadow: 0 8px 30px rgba(0,0,0,0.5);
    }
    .icon-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: var(--muted);
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .icon-btn.active { background: #e53935; }
    .leave-btn {
      background: #ff3b30;
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
    }

    /* Pre-call log at bottom-left (small) */
    .log {
      position: absolute;
      left: 16px;
      bottom: 16px;
      z-index: 45;
      max-width: 320px;
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #localContainer { width: 120px; height: 84px; top: 10px; left: 10px; }
      .topbar input { width: 140px; }
    }
  </style>
</head>
<body>
  <div class="call-wrap">
    <div class="topbar">
      <input id="name" placeholder="Enter your name..." />
      <button id="registerBtn">Register</button>
      <button id="findBtn" disabled>Find Partner</button>
      <button id="endBtn" disabled>End</button>
    </div>

    <div class="stage">
      <video id="remoteVideo" autoplay playsinline></video>

      <div id="localContainer">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="local-label">You</div>
      </div>

      <div class="controls-bottom" id="controlsBottom" style="display:none;">
        <button id="micBtn" class="icon-btn">ðŸŽ¤</button>
        <button id="camBtn" class="icon-btn">ðŸŽ¥</button>
        <button id="speakerBtn" class="icon-btn">ðŸ”ˆ</button>
        <button id="leaveBtn" class="leave-btn">Leave</button>
      </div>

      <div class="log" id="log" style="display:none;"></div>
    </div>
  </div>

  <script>
    const socket = io("https://server-09p9.onrender.com");
    const nameInput = document.getElementById('name');
    const registerBtn = document.getElementById('registerBtn');
    const findBtn = document.getElementById('findBtn');
    const endBtn = document.getElementById('endBtn');

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const localContainer = document.getElementById('localContainer');
    const controlsBottom = document.getElementById('controlsBottom');
    const logDiv = document.getElementById('log');

    const micBtn = document.getElementById('micBtn');
    const camBtn = document.getElementById('camBtn');
    const speakerBtn = document.getElementById('speakerBtn');
    const leaveBtn = document.getElementById('leaveBtn');

    let localStream = null;
    let remoteStream = null;
    let pc = null;
    let partnerId = null;
    let pendingCandidates = [];
    let micOn = true, camOn = true, speakerOn = true;

    const log = (msg) => {
      logDiv.style.display = 'block';
      const el = document.createElement('div');
      el.textContent = msg;
      logDiv.appendChild(el);
      logDiv.scrollTop = logDiv.scrollHeight;
    };

    // Register / find
    registerBtn.onclick = () => {
      const name = nameInput.value.trim();
      if (!name) return alert('Enter a name first');
      socket.emit('register', name);
      registerBtn.disabled = true;
      findBtn.disabled = false;
      log('Registered as ' + name);
    };

    findBtn.onclick = async () => {
      socket.emit('find-partner');
      findBtn.disabled = true;
      log('Searching for partner...');
    };

    endBtn.onclick = () => {
      if (partnerId) socket.emit('end-call', { partnerId });
      cleanup();
      log('Call ended by you.');
    };

    leaveBtn.onclick = () => {
      if (partnerId) socket.emit('end-call', { partnerId });
      cleanup();
      log('You left the call.');
    };

    // Toggle buttons
    micBtn.onclick = () => {
      micOn = !micOn;
      if (localStream) localStream.getAudioTracks().forEach(t => t.enabled = micOn);
      micBtn.classList.toggle('active', !micOn);
      micBtn.textContent = micOn ? 'ðŸŽ¤' : 'ðŸ”‡';
    };

    camBtn.onclick = () => {
      camOn = !camOn;
      if (localStream) localStream.getVideoTracks().forEach(t => t.enabled = camOn);
      camBtn.classList.toggle('active', !camOn);
      camBtn.textContent = camOn ? 'ðŸŽ¥' : 'ðŸ“·';
    };

    speakerBtn.onclick = () => {
      speakerOn = !speakerOn;
      remoteVideo.muted = !speakerOn;
      speakerBtn.classList.toggle('active', !speakerOn);
      speakerBtn.textContent = speakerOn ? 'ðŸ”ˆ' : 'ðŸ”‡';
    };

    // Create peer connection, attach local tracks
    async function createPeerConnection() {
      if (pc) return;

      pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
        ]
      });

      // Prepare remote stream container
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;
      remoteVideo.muted = false; // ensure audio plays
      remoteVideo.autoplay = true;
      remoteVideo.playsInline = true;

      pc.ontrack = (event) => {
        // Add all tracks to remoteStream (works for both audio and video)
        event.streams?.[0]
          ? event.streams[0].getTracks().forEach(t => remoteStream.addTrack(t))
          : remoteStream.addTrack(event.track);
        // try to play (autoplay policies may block - ignore errors)
        remoteVideo.play().catch(()=>{});
      };

      pc.onicecandidate = (e) => {
        if (e.candidate && partnerId) {
          socket.emit('signal', { to: partnerId, candidate: e.candidate });
        }
      };

      // Add local tracks if present
      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }

      // When remote description is set later, flush pending candidates
      pc.onconnectionstatechange = () => {
        log('PC state: ' + pc.connectionState);
      };
    }

    function cleanup() {
      if (pc) { try { pc.close(); } catch(_){} pc = null; }
      if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      if (remoteStream) { remoteStream.getTracks().forEach(t => t.stop()); remoteStream = null; }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      localContainer.style.display = 'none';
      controlsBottom.style.display = 'none';
      partnerId = null;
      pendingCandidates = [];
      endBtn.disabled = true;
      findBtn.disabled = false;
    }

    // Socket handlers
    socket.on('status', (msg) => log(msg));
    socket.on('waiting', (msg) => log(msg));
    socket.on('partner-left', () => {
      log('âš ï¸ Partner left.');
      cleanup();
    });
    socket.on('call-ended', () => {
      log('ðŸ“ž Call ended.');
      cleanup();
    });

    // partner-found: includes initiator boolean from server
    socket.on('partner-found', async ({ partnerId: pId, partnerName, initiator }) => {
      log('Partner found: ' + partnerName + (initiator ? ' (you will create offer)' : ''));
      partnerId = pId;
      endBtn.disabled = false;
      controlsBottom.style.display = 'flex';

      // get local media
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      } catch (err) {
        alert('Could not get camera/microphone: ' + err.message);
        log('Media error: ' + err.message);
        return;
      }

      // show local small preview
      localVideo.srcObject = localStream;
      localContainer.style.display = 'block';

      await createPeerConnection();

      // Add tracks if pc created after localStream
      if (localStream && pc) {
        // ensure tracks are added (avoid double-add)
        const senders = pc.getSenders().map(s => s.track).filter(Boolean);
        localStream.getTracks().forEach(track => {
          if (!senders.includes(track)) pc.addTrack(track, localStream);
        });
      }

      // only initiator creates offer
      if (initiator) {
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit('signal', { to: partnerId, offer });
          log('ðŸ“¡ Offer sent to partner.');
        } catch (err) {
          console.error('Offer error', err);
          log('âš ï¸ Offer error: ' + err.message);
        }
      }
    });

    // signaling messages: { from, offer, answer, candidate }
    socket.on('signal', async ({ from, offer, answer, candidate }) => {
      try {
        if (!pc) await createPeerConnection();

        if (offer) {
          log('ðŸ“¨ Offer received. Creating answer...');
          await pc.setRemoteDescription(new RTCSessionDescription(offer));

          // flush any queued ICE candidates now
          if (pendingCandidates.length) {
            for (const c of pendingCandidates) {
              await pc.addIceCandidate(c).catch(()=>{});
            }
            pendingCandidates = [];
          }

          const answerDesc = await pc.createAnswer();
          await pc.setLocalDescription(answerDesc);
          socket.emit('signal', { to: from, answer: answerDesc });
          log('ðŸ“£ Answer sent.');
        } else if (answer) {
          log('âœ… Answer received.');
          await pc.setRemoteDescription(new RTCSessionDescription(answer));

          // flush queued candidates after remote description set
          if (pendingCandidates.length) {
            for (const c of pendingCandidates) {
              await pc.addIceCandidate(c).catch(()=>{});
            }
            pendingCandidates = [];
          }
        } else if (candidate) {
          const ice = new RTCIceCandidate(candidate);
          // If remoteDescription not set yet, queue candidate
          if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(ice).catch(err => {
              console.warn('addIceCandidate failed', err);
            });
          } else {
            pendingCandidates.push(ice);
          }
        }
      } catch (err) {
        console.error('Signal handler error', err);
        log('âš ï¸ Signal error: ' + err.message);
      }
    });

    // Clean up on disconnect just in case
    socket.on('disconnect', () => {
      log('Disconnected from server.');
      cleanup();
    });

    // Optional: show server connection
    socket.on('connect', () => log('Connected to signaling server. ID: ' + socket.id));
  </script>
</body>
</html>
